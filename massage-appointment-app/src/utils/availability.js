// src/utils/availability.js
import moment from 'moment';

// Define general clinic working hours (start and end time for each day)
// FUTURE ENHANCEMENT: Store this per therapist in Firestore.
const CLINIC_HOURS = {
  0: { start: '09:00', end: '17:00' }, // Sunday
  1: { start: '09:00', end: '17:00' }, // Monday
  2: { start: '09:00', end: '17:00' }, // Tuesday
  3: { start: '09:00', end: '17:00' }, // Wednesday
  4: { start: '09:00', end: '17:00' }, // Thursday
  5: { start: '09:00', end: '17:00' }, // Friday
  6: { start: '09:00', end: '17:00' }, // Saturday
};

export const SERVICE_DURATIONS = {
  "Swedish Massage": 60,
  "Deep Tissue Massage": 90,
  "Hot Stone Therapy": 75,
  "Aromatherapy Massage": 60,
};

/**
 * Generates all possible time slots for a given date based on clinic hours and service duration.
 * (No change needed here based on therapist ID for now, as CLINIC_HOURS is global)
 */
export const generateAvailableSlots = (date, durationMinutes) => {
  const dayOfWeek = moment(date).day();
  const hours = CLINIC_HOURS[dayOfWeek];

  if (!hours) {
    return [];
  }

  const start = moment(date).hour(parseInt(hours.start.split(':')[0])).minute(parseInt(hours.start.split(':')[1])).second(0);
  const end = moment(date).hour(parseInt(hours.end.split(':')[0])).minute(parseInt(hours.end.split(':')[1])).second(0);

  const slots = [];
  let currentSlot = moment(start);

  while (currentSlot.clone().add(durationMinutes, 'minutes').isSameOrBefore(end)) {
    // Only add slots if they are in the future
    if (currentSlot.isSameOrAfter(moment(), 'minute')) { // Check if slot is now or in the future
      slots.push(currentSlot.clone());
    }
    currentSlot.add(15, 'minutes');
  }

  return slots;
};

/**
 * Filters generated slots against already booked appointments, considering the therapist.
 * @param {Array<moment.Moment>} generatedSlots - Slots generated by generateAvailableSlots.
 * @param {Array<Object>} bookedAppointments - Array of booked appointments from Firestore.
 * @param {number} durationMinutes - The duration of the service in minutes.
 * @param {string} [excludeAppointmentId=null] - Optional: ID of an appointment to exclude from conflict checks (for rescheduling).
 * @param {string} [selectedTherapistId=null] - NEW: ID of the therapist for whom to check availability.
 * @returns {Array<moment.Moment>} - Filtered array of truly available slots.
 */
export const filterBookedSlots = (generatedSlots, bookedAppointments, durationMinutes, excludeAppointmentId = null, selectedTherapistId = null) => {
  return generatedSlots.filter(slot => {
    const slotStart = slot.clone();
    const slotEnd = slot.clone().add(durationMinutes, 'minutes');

    const isConflict = bookedAppointments.some(bookedAppt => {
      // If we're rescheduling, don't conflict with the appointment we are currently editing
      if (excludeAppointmentId && bookedAppt.id === excludeAppointmentId) {
        return false;
      }

      // NEW: Only consider a conflict if the therapist ID matches
      if (selectedTherapistId && bookedAppt.therapistId !== selectedTherapistId) {
        return false; // This appointment is for a different therapist, so it's not a conflict for this slot
      }

      const bookedStart = moment(bookedAppt.dateTime);
      const bookedEnd = bookedStart.clone().add(SERVICE_DURATIONS[bookedAppt.service] || 60, 'minutes');

      // Overlap logic: (StartA < EndB) && (EndA > StartB)
      return slotStart.isBefore(bookedEnd) && slotEnd.isAfter(bookedStart);
    });

    return !isConflict; // The check for future dates is now in generateAvailableSlots
  });
};